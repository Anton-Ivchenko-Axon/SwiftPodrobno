/* 
  Tasks.strings
  SwiftPodrobno

  Created by Anton Ivchenko on 14.04.2022.
  
*/

Упражнение 2.3.6

1.1. Можно сделать свой супперкласс и передавать его в методы и свойства подкласса, не создавая лишних
1.2. При добавлении метода или переменной в модели суперкласса их не нужно обрабатывать в их подклассах

2.1. Возможность добавления новых моделей без рефакторинга основной модели данных
2.2. Безопасность на этапе компиляции (компилятор просить обработать все кейсы, если вы забыли про какой-то из них)

Упражнение 2.4.4

1. 12 вариация

2. enum Bagel {
     case bagel(topping: Topping, bagelType: BagelType)
   }

3.  struct Baby {
    var numberOfPieces: Int
    }

    struct Toddler {
    var numberOfPieces: Int
    }

    struct Preschooler {
    var numberOfPieces: Int
    }

    struct Gradeschooler {
    var numberOfPieces: Int
    }

    struct Teenager {
    var numberOfPieces: Int
    }

Упражнение 2.5.3

1. String, Character, Int, Double, Float
2. На этапе компиляции
3. Во время выполнения
4. Любые

Упражнение 3.2.6

1. var age: Int? {
     let years = Calendar.current
         .dateComponents([.year], from: Date(), to: birthDate)
         .day
     return years
   }

   lazy private(set) var songs: [Song] = {
       guard let fileURL = Bundle.main.url(forResource: songsFileName, withExtension: "plist"),
       let data = try? Data(contentsOf: fileURL),
       let songs = try? PropertyListDecoder().decode([Song].self, from:
                                                       data) else {
       return [] }
       return songs
    }()

2. Да, можно сделать private(set) чтобы не дать возможность изменять свойство song из вне.
3. Либо сделать songsFileName контстантой, либо преобразовать структуру в класс, тогда свойства будут не копироваться а ссылаться на то же самое свойство.

Упражнение 3.3.3

1. Var с didSet/willSet
2. Вычисляемое или ленивое
3. init(date: Date, author: String, message: String) {
      defer { self.message = message }
      self.date = date
      self.author = author
      self.message = message
   }

Упражнение 4.6.1

1. Можно воспользоваться guard
2. Поместить опционалы в один Tuple

Упражнение 4.8.1

1. func describeAction(event: PasteBoardEvent?, contents: PasteBoardContents?) -> String {
        switch (event, contents) {
            case let(.added?, .url(url)?):
                return "User added an url to pasteboard: \(url)"
            case (.added?, .emailAddress(_)?):
                return "User added something to pasteboard."
            case (.erased?,.emailAddress(_)?):
                return "User erased an email address from the pasteboard."
            case (.erased?, _):
                return "The pasteboard is updated."
            case (_, .other(_)?):
                return "The pasteboard is updated."
            default:
                return "The pasteboard is updated"
            }
    }

Упражнение 4.10.5

1. enum AudioSetting: RawRepresentable {
    
        case audioEnabled
        case audioDisabled
        case notSet
    
        init(rawValue: Bool?) {
            switch rawValue {
                case true?: self = .audioEnabled
                case false?: self = .audioDisabled
                default: self = .notSet
            }
        }

        var rawValue: Bool? {
            switch self {
                case .audioEnabled: return true
                case .audioDisabled: return false
                case .notSet: return nil
            }
        }
    }

Упражнение 4.12.3

1. Можно пользоваться lazy свойствами или передать фабрику в нужный класс
